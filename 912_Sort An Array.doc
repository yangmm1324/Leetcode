912. Sort an Array  Medium

Given an array of integers nums, sort the array in ascending order.

Example 1:

Input: nums = [5,2,3,1]
Output: [1,2,3,5]

1. Clarification:
  null array
  required stable sort or not?
     Yes: bublle_sort, insertion_sort,Mergesort;
     No: Quicksort, heapsort
  time complexity?
    o(n^2): bubble_sort, insertion_sort-o(n2)
    o(nlogn): mergeSort, quicksort, heapsort
    o(n): counting sort, if maximum value is close to n
  what is the range of the element, num[i]<0, need to be careful with counting sort

  optimization:
      if the nums is almost sort, we can use insertion or bublle sort

2. algorithm:
def insertionSort(nums):
    if not nums: return nums
    for i in range(1,len(nums)):
        current = nums[i]
        j = i-1
        while j>=0 and nums[j]>current:
            nums[j+1] = nums[j]
            j -= 1
        nums[j+1] = current
    return nums

def bubbleSort(nums):
    sorted=False
    n = len(nums)
    for i in range(n):
        if sorted: break
        sorted = True
        for j in range(n-1, i, -1):
            if nums[j-1]>nums[j]:
                sorted = False
                nums[j], nums[j-1]=nums[j-1], nums[j]
    return nums

def mergeSort(nums):
    if len(nums)<=1: return nums
    mid = len(nums)//2
    left = nums[:mid]
    right = nums[mid:]
    mergeSort(left)
    mergeSort(right)
    i = j = k = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            nums[k] = left[i]
            i += 1
        else:
            nums[k] = right[j]
            j += 1
        k += 1
    nums[k:] = left[i:] or right[j:]
    return nums

def quickSort(nums, start, end):
    def partition(nums, start, end):
        pivot = start
        i = start + 1
        for j in range(start+1, end+1):
            if nums[j] < nums[pivot]:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
        nums[pivot], nums[i-1] = nums[i - 1], nums[pivot]
        pivot = i - 1
        return pivot

    def partitionRand(nums, start, end):
        randPivot=random.randrange(start, end)
        nums[start], nums[randPivot]=nums[randPivot],nums[start]
        return partition(nums, start, end)

    if start >= end:
        return nums

    pivotIndex = partitionRand(nums, start, end)
    quickSort(nums, start, pivotIndex - 1)
    quickSort(nums, pivotIndex + 1, end)

def countingSort(nums):
    count = [0] * max(nums)
    ans = []
    for num in nums:
        count[nums - 1] += 1
    for i, num in enumerate(count):
        if num == 0: continue
        ans.extend([i+1]*num)
    return ans
